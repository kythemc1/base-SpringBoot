package co.siten.osp.birt.service;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.net.URLDecoder;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;

import co.siten.osp.birt.bean.Report;
import org.eclipse.birt.core.exception.BirtException;
import org.eclipse.birt.core.framework.Platform;
import org.eclipse.birt.report.engine.api.EngineConfig;
import org.eclipse.birt.report.engine.api.EngineException;
import org.eclipse.birt.report.engine.api.HTMLRenderOption;
import org.eclipse.birt.report.engine.api.HTMLServerImageHandler;
import org.eclipse.birt.report.engine.api.IImage;
import org.eclipse.birt.report.engine.api.IPDFRenderOption;
import org.eclipse.birt.report.engine.api.IRenderTask;
import org.eclipse.birt.report.engine.api.IReportDocument;
import org.eclipse.birt.report.engine.api.IReportEngine;
import org.eclipse.birt.report.engine.api.IReportEngineFactory;
import org.eclipse.birt.report.engine.api.IReportRunnable;
import org.eclipse.birt.report.engine.api.IRunTask;
import org.eclipse.core.internal.registry.RegistryProviderFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.core.env.Environment;
import org.springframework.stereotype.Service;


@Service
@Qualifier("birt")
public class BIRTReportRunner implements ReportRunner {
	private static final String DEFAULT_LOGGING_DIRECTORY = "defaultBirtLoggingDirectory/";
	private Logger logger = LoggerFactory.getLogger(BIRTReportRunner.class);

	private String reportOutputDirectory;

	private IReportEngine birtReportEngine = null;

	@Autowired
	private Environment env;

	/**
	 * Starts up and configures the BIRT Report Engine
	 */
	@PostConstruct
	public void startUp() {
		try {
			String birtLoggingDirectory = env.getProperty("birt_logging_directory") == null ? DEFAULT_LOGGING_DIRECTORY
					: env.getProperty("birt_logging_directory");
			Level birtLoggingLevel = env.getProperty("birt_logging_level") == null ? Level.SEVERE
					: Level.parse(env.getProperty("birt_logging_level"));
			EngineConfig engineConfig = new EngineConfig();
			logger.info("BIRT LOG DIRECTORY SET TO : {}", birtLoggingDirectory);
			logger.info("BIRT LOGGING LEVEL SET TO {}", birtLoggingLevel);
			engineConfig.setLogConfig(birtLoggingDirectory, birtLoggingLevel);

			// Required due to a bug in BIRT that occurs in calling Startup
			// after the
			// Platform has already been started up
			RegistryProviderFactory.releaseDefault();
			Platform.startup(engineConfig);
			IReportEngineFactory reportEngineFactory = (IReportEngineFactory) Platform
					.createFactoryObject(IReportEngineFactory.EXTENSION_REPORT_ENGINE_FACTORY);
			birtReportEngine = reportEngineFactory.createReportEngine(engineConfig);
		} catch (BirtException e) {
			// TODO add logging aspect and find out how to log a platform
			// startup problem
			// from this catch block, if possible, using the aspect.
			// Possibly rethrow the exception here and catch it in the aspect.
			logger.error("Birt Startup Error: {}", e.getMessage());
		}

		reportOutputDirectory = env.getProperty("birt_temp_file_output_dir");
	}

	/**
	 * Shuts down the BIRT Report Engine
	 */
	@PreDestroy
	public void shutdown() {
		birtReportEngine.destroy();
		RegistryProviderFactory.releaseDefault();
		Platform.shutdown();
	}

	public File getReportFromFilesystem(String reportName) {
		String reportDirectory = env.getProperty("birt_report_input_dir");
		Path birtReport = Paths.get(reportDirectory + File.separator + reportName + ".rptdesign");

		return birtReport.toFile();
	}

	/**
	 * This method creates and executes the report task, the main responsibility
	 * of the entire Report Service. This method is key to enabling pagination
	 * for the BIRT report. The IRunTask run task is created and then used to
	 * generate an ".rptdocument" binary file. This binary file is then read by
	 * the separately created IRenderTask render task. The render task renders
	 * the binary document as a binary PDF output stream which is then returned
	 * from the method.
	 * <p>
	 *
	 * @param birtReport
	 *            the report object created at the controller to hold the data
	 *            of the report request.
	 * @return Returns a ByteArrayOutputStream of the PDF bytes generated by the
	 */
	@Override
	public ByteArrayOutputStream runReport(Report birtReport) {

		String rptdocument = reportOutputDirectory + File.separator + "generated" + File.separator
				+ birtReport.getName() + ".rptdocument";

		// try {
		// Files.deleteIfExists(Paths.get(rptdocument));
		// } catch (IOException e) {
		// // TODO Auto-generated catch block
		// e.printStackTrace();
		// }

		ByteArrayOutputStream byteArrayOutputStream;
		File rptDesignFile;

		// get the path to the report design file
		try {
			rptDesignFile = getReportFromFilesystem(birtReport.getName());
		} catch (Exception e) {
			logger.error("Error while loading rptdesign: {}.", e.getMessage());
			return null;
		}

		// process any additional parameters
		Map<String, String> parsedParameters = parseParametersAsMap(birtReport.getParameters());

		byteArrayOutputStream = new ByteArrayOutputStream();
		try {
			IReportRunnable reportDesign = birtReportEngine.openReportDesign(rptDesignFile.getPath());
			IRunTask runTask = birtReportEngine.createRunTask(reportDesign);

			if (parsedParameters.size() > 0) {
				for (Map.Entry<String, String> entry : parsedParameters.entrySet()) {
					if (entry.getKey().equals("url")) {
						runTask.setParameterValue(entry.getKey(), URLDecoder.decode(entry.getValue()));
					} else {
						runTask.setParameterValue(entry.getKey(), entry.getValue());
					}

				}
			}
			runTask.validateParameters();

			runTask.run(rptdocument);

			IReportDocument reportDocument = birtReportEngine.openReportDocument(rptdocument);
			IRenderTask renderTask = birtReportEngine.createRenderTask(reportDocument);

			HTMLRenderOption htmlRenderOption = new HTMLRenderOption();
			htmlRenderOption.setOption(IPDFRenderOption.HTML_PAGINATION, new Boolean(true));
			htmlRenderOption.setOutputFormat("html");
			htmlRenderOption.setOutputStream(byteArrayOutputStream);
			htmlRenderOption.setEmbeddable(true);
			htmlRenderOption.setEnableInlineStyle(true);
			htmlRenderOption.setImageHandler(new HTMLServerImageHandler() {
				@Override
				protected String handleImage(IImage image, Object context, String prefix, boolean needMap) {
					StringBuilder ret = new StringBuilder();
					ret.append("data:" + image.getMimeType() + ";base64,");
					ret.append(Base64.getEncoder().encodeToString((image.getImageData())));
					return ret.toString();
				}
			});
			renderTask.setRenderOption(htmlRenderOption);

			renderTask.render();
			renderTask.close();
			reportDocument.close();

		} catch (EngineException e) {
			e.printStackTrace();
			logger.error("Error while running report task: {}.", e.getMessage());
		}

		return byteArrayOutputStream;
	}

	/**
	 * Takes a String of parameters started by '?', delimited by '&', and with
	 * keys and values split by '=' and returnes a Map of the keys and values in
	 * the String.
	 *
	 * @param reportParameters
	 *            a String from a HTTP request URL
	 * @return a map of parameters with Key,Value entries as strings
	 */
	public Map<String, String> parseParametersAsMap(String reportParameters) {
		Map<String, String> parsedParameters = new HashMap<String, String>();
		String[] paramArray;
		String noQuestionMark = reportParameters.substring(1, reportParameters.length());
		paramArray = noQuestionMark.split("&");
		for (String param : paramArray) {
			String[] paramGroup = param.split("=");
			if (paramGroup.length == 2) {
				parsedParameters.put(paramGroup[0], paramGroup[1]);
			} else {
				parsedParameters.put(paramGroup[0], "");
			}

		}
		return parsedParameters;
	}
}